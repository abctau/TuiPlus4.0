import BitByte from './8BitByte';
import RSBlock from './RSBlock';
import BitBuffer from './BitBuffer';
import Util from './util';
import Polynomial from './Polynomial';
import { QRCodeInterface } from './interface.uts'
export class QRCode implements QRCodeInterface {
	public typeNumber : number;
	public errorCorrectLevel : number; // 您应该为错误校正级别定义一个类型或枚举
	public modules : Array<Array<boolean | null>>;
	public moduleCount : number;
	public dataCache : number[]; // 如果可能，请替换'any'为实际类型
	public dataList : BitByte[];
	public PAD0 = 0xEC;
	public PAD1 = 0x11;
	util = new Util()
	constructor(typeNumber : number, errorCorrectLevel : number) {
		this.typeNumber = typeNumber;
		this.errorCorrectLevel = errorCorrectLevel;
		this.modules = [];
		this.moduleCount = 0;
		this.dataCache = [];
		this.dataList = [];
	}
	addData(data : string) {
		var newData = new BitByte(data);
		this.dataList.push(newData);
		this.dataCache = [];
	}


	isDark(row : number, col : number) : boolean {
		if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
			throw new Error(row + "," + col);
		}
		return this.modules[row][col] as boolean;
	}

	getModulesCount() : number {
		return this.moduleCount;
	}

	make() {
		if (this.typeNumber < 1) {
			var typeNumber : number
			for (typeNumber = 1; typeNumber < 40; typeNumber++) {
				var rsBlocks = (new RSBlock(typeNumber, this.errorCorrectLevel)).getRSBlocks(typeNumber, this
					.errorCorrectLevel);

				var buffer = new BitBuffer();
				var totalDataCount = 0;
				for (var i = 0; i < rsBlocks.length; i++) {
					totalDataCount += rsBlocks[i].dataCount;
				}

				for (var i = 0; i < this.dataList.length; i++) {
					var data = this.dataList[i];
					buffer.put(data.mode, 4);
					buffer.put(data.getLength(), this.util.getLengthInBits(data.mode, typeNumber));
					data.write(buffer);
				}
				if (buffer.getLengthInBits() <= totalDataCount * 8)
					break;
			}
			this.typeNumber = typeNumber;
		}
		this.makeImpl(false, 6);
	}

	makeImpl(test : boolean, maskPattern : number) {

		this.moduleCount = this.typeNumber * 4 + 17;
		this.modules = []

		for (var row = 0; row < this.moduleCount; row++) {

			this.modules.push([])

			for (var col = 0; col < this.moduleCount; col++) {
				this.modules[row].push(null) //(col + row) % 3;
			}
		}

		this.setupPositionProbePattern(0, 0);
		this.setupPositionProbePattern(this.moduleCount - 7, 0);
		this.setupPositionProbePattern(0, this.moduleCount - 7);
		this.setupPositionAdjustPattern();
		this.setupTimingPattern();
		this.setupTypeInfo(test, maskPattern);

		if (this.typeNumber >= 7) {
			this.setupTypeNumber(test);
		}

		if (this.dataCache.length == 0) {
			this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
		}

		this.mapData(this.dataCache, maskPattern);
	}
	setupPositionProbePattern(row : number, col : number) {

		for (var r = -1; r <= 7; r++) {

			if (row + r <= -1 || this.moduleCount <= row + r) continue;

			for (var c = -1; c <= 7; c++) {

				if (col + c <= -1 || this.moduleCount <= col + c) continue;

				if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
					(0 <= c && c <= 6 && (r == 0 || r == 6)) ||
					(2 <= r && r <= 4 && 2 <= c && c <= 4)) {
					this.modules[row + r][col + c] = true;
				} else {
					this.modules[row + r][col + c] = false;
				}
			}
		}
	}

	getBestMaskPattern() : number {

		var minLostPoint = 0;
		var pattern = 0;

		for (var i = 0; i < 8; i++) {

			this.makeImpl(true, i);

			var lostPoint = this.util.getLostPoint(this);

			if (i == 0 || minLostPoint > lostPoint) {
				minLostPoint = lostPoint;
				pattern = i;
			}
		}

		return pattern;
	}
	setupTimingPattern() {

		for (var r = 8; r < this.moduleCount - 8; r++) {
			if (this.modules[r][6] != null) {
				continue;
			}
			this.modules[r][6] = (r % 2 == 0);
		}

		for (var c = 8; c < this.moduleCount - 8; c++) {
			if (this.modules[6][c] != null) {
				continue;
			}
			this.modules[6][c] = (c % 2 == 0);
		}
	}

	setupPositionAdjustPattern() {

		var pos = this.util.getPatternPosition(this.typeNumber);

		for (var i = 0; i < pos.length; i++) {

			for (var j = 0; j < pos.length; j++) {

				var row = pos[i];
				var col = pos[j];

				if (this.modules[row][col] != null) {
					continue;
				}

				for (var r = -2; r <= 2; r++) {

					for (var c = -2; c <= 2; c++) {

						if (r == -2 || r == 2 || c == -2 || c == 2 ||
							(r == 0 && c == 0)) {
							this.modules[row + r][col + c] = true;
						} else {
							this.modules[row + r][col + c] = false;
						}
					}
				}
			}
		}
	}
	setupTypeNumber(test : boolean) {

		var bits = this.util.getBCHTypeNumber(this.typeNumber);

		for (var i = 0; i < 18; i++) {
			var mod = (!test && ((bits >> i) & 1) == 1);
			this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
		}

		for (var i = 0; i < 18; i++) {
			var mod = (!test && ((bits >> i) & 1) == 1);
			this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
		}
	}

	setupTypeInfo(test : boolean, maskPattern : number) {

		var data = (this.errorCorrectLevel << 3) | maskPattern;
		var bits = this.util.getBCHTypeInfo(data);

		// vertical
		for (var i = 0; i < 15; i++) {

			var mod = (!test && ((bits >> i) & 1) == 1);

			if (i < 6) {
				this.modules[i][8] = mod;
			} else if (i < 8) {
				this.modules[i + 1][8] = mod;
			} else {
				this.modules[this.moduleCount - 15 + i][8] = mod;
			}
		}

		// horizontal
		for (var i = 0; i < 15; i++) {

			var mod = (!test && ((bits >> i) & 1) == 1);

			if (i < 8) {
				this.modules[8][this.moduleCount - i - 1] = mod;
			} else if (i < 9) {
				this.modules[8][15 - i - 1 + 1] = mod;
			} else {
				this.modules[8][15 - i - 1] = mod;
			}
		}

		// fixed module
		this.modules[this.moduleCount - 8][8] = (!test);
	}


	mapData(data : number[], maskPattern : number) {

		var inc = -1;
		var row = this.moduleCount - 1;
		var bitIndex = 7;
		var byteIndex = 0;

		for (var col = this.moduleCount - 1; col > 0; col -= 2) {

			if (col == 6) col--;

			while (true) {

				for (var c = 0; c < 2; c++) {

					if (this.modules[row][col - c] == null) {

						var dark = false;

						if (byteIndex < data.length) {
							dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
						}

						var mask = this.util.getMask(maskPattern, row, col - c);

						if (mask) {
							dark = !dark;
						}

						this.modules[row][col - c] = dark;
						bitIndex--;

						if (bitIndex == -1) {
							byteIndex++;
							bitIndex = 7;
						}
					}
				}

				row += inc;

				if (row < 0 || this.moduleCount <= row) {
					row -= inc;
					inc = -inc;
					break;
				}
			}
		}
	}
	createData(typeNumber : number, errorCorrectLevel : number, dataList : BitByte[]) : number[] {

		var rsBlocks = (new RSBlock(typeNumber, errorCorrectLevel)).getRSBlocks(typeNumber, errorCorrectLevel);

		var buffer = new BitBuffer();

		for (var i = 0; i < dataList.length; i++) {
			var data = dataList[i];
			buffer.put(data.mode, 4);
			buffer.put(data.getLength(), this.util.getLengthInBits(data.mode, typeNumber));
			data.write(buffer);
		}

		// calc num max data.
		var totalDataCount = 0;
		for (var i = 0; i < rsBlocks.length; i++) {
			totalDataCount += rsBlocks[i].dataCount;
		}

		if (buffer.getLengthInBits() > totalDataCount * 8) {
			throw new Error("code length overflow. (" +
				buffer.getLengthInBits() +
				">" +
				totalDataCount * 8 +
				")");
		}

		// end code
		if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
			buffer.put(0, 4);
		}

		// padding
		while (buffer.getLengthInBits() % 8 != 0) {
			buffer.putBit(false);
		}

		// padding
		while (true) {

			if (buffer.getLengthInBits() >= totalDataCount * 8) {
				break;
			}
			buffer.put(this.PAD0, 8);

			if (buffer.getLengthInBits() >= totalDataCount * 8) {
				break;
			}
			buffer.put(this.PAD1, 8);
		}

		return this.createBytes(buffer, rsBlocks);
	}

	createBytes(buffer : BitBuffer, rsBlocks : RSBlock[]) : number[] {

		var offset = 0;

		var maxDcCount = 0;
		var maxEcCount = 0;

		var dcdata : number[][] = []
		var ecdata : number[][] = []

		for (var r = 0; r < rsBlocks.length; r++) {
			var dcCount = rsBlocks[r].dataCount;
			var ecCount = rsBlocks[r].totalCount - dcCount;

			maxDcCount = Math.max(maxDcCount, dcCount);
			maxEcCount = Math.max(maxEcCount, ecCount);

			dcdata.push([] as number[])

			for (var i = 0; i < dcCount; i++) {
				dcdata[r].push(0xff & buffer.buffer[i + offset])
			}
			offset += dcCount;
			var rsPoly = this.util.getErrorCorrectPolynomial(ecCount);
			var rawPoly = new Polynomial(dcdata[r], rsPoly.getLength() - 1);
			var modPoly = rawPoly.mod(rsPoly);
			ecdata.push([] as number[])
			for (var i = 0; i < (rsPoly.getLength() - 1); i++) {
				var modIndex = i + modPoly.getLength() - (rsPoly.getLength() - 1);
				ecdata[r].push((modIndex >= 0) ? modPoly.get(modIndex) : 0);
			}
		}

		var totalCodeCount = 0;
		for (var i = 0; i < rsBlocks.length; i++) {
			totalCodeCount += rsBlocks[i].totalCount;
		}

		var data : number[] = [];


		for (var i = 0; i < maxDcCount; i++) {
			for (var r = 0; r < rsBlocks.length; r++) {
				if (i < dcdata[r].length) {
					data.push(dcdata[r][i]);
				}
			}
		}

		for (var i = 0; i < maxEcCount; i++) {
			for (var r = 0; r < rsBlocks.length; r++) {
				if (i < ecdata[r].length) {
					data.push(ecdata[r][i]);
				}
			}
		}
		return data;
	}

}