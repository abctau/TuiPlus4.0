import { WordArray, Utf8, Hex, operationZero } from './core';
import { TuiArray } from '../core/array'
const T : number[] = [];

for (let i = 0; i < 64; i += 1) {
	const a : number = operationZero(Math.abs(Math.sin(i + 1)) * 0x100000000)
	T.push(a)
}

const FF = (a : number, b : number, c : number, d : number, x : number, s : number, t : number) : number => {
	const n = a + ((b & c) | (~b & d)) + x + t;
	return ((n << s) | (n >>> (32 - s))) + b;
};

const GG = (a : number, b : number, c : number, d : number, x : number, s : number, t : number) : number => {
	const n = a + ((b & d) | (c & ~d)) + x + t;
	return ((n << s) | (n >>> (32 - s))) + b;
};

const HH = (a : number, b : number, c : number, d : number, x : number, s : number, t : number) : number => {
	const n = a + (b ^ c ^ d) + x + t;
	return ((n << s) | (n >>> (32 - s))) + b;
};

const II = (a : number, b : number, c : number, d : number, x : number, s : number, t : number) : number => {
	const n = a + (c ^ (b | ~d)) + x + t;
	return ((n << s) | (n >>> (32 - s))) + b;
};

/**
 * MD5 hash algorithm.
 */
const HD = new TuiArray()
HD.push(...([
	0x67452301,
	0xefcdab89,
	0x98badcfe,
	0x10325476,
] as number[]))
export class MD5Algo {
	blockSize : number = 512 / 32
	_hash : WordArray
	_data : WordArray = new WordArray()
	_nDataBytes : number = 0
	constructor() {
		this._hash = new WordArray(HD.copy());
	}
	_doReset() {
		this._hash = new WordArray(HD.copy());
	}
	_doProcessBlock(M : TuiArray, offset : number) {
		const _M = M;
		for (let i = 0; i < 16; i += 1) {
			const offset_i = offset + i;
			const M_offset_i = M.getValue(offset_i);
			_M.setValue(offset_i, ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
			));
		}
		const H : TuiArray = this._hash.words;
		const M_offset_0 = _M.getValue(offset + 0);
		const M_offset_1 = _M.getValue(offset + 1);
		const M_offset_2 = _M.getValue(offset + 2);
		const M_offset_3 = _M.getValue(offset + 3);
		const M_offset_4 = _M.getValue(offset + 4);
		const M_offset_5 = _M.getValue(offset + 5);
		const M_offset_6 = _M.getValue(offset + 6);
		const M_offset_7 = _M.getValue(offset + 7);
		const M_offset_8 = _M.getValue(offset + 8);
		const M_offset_9 = _M.getValue(offset + 9);
		const M_offset_10 = _M.getValue(offset + 10);
		const M_offset_11 = _M.getValue(offset + 11);
		const M_offset_12 = _M.getValue(offset + 12);
		const M_offset_13 = _M.getValue(offset + 13);
		const M_offset_14 = _M.getValue(offset + 14);
		const M_offset_15 = _M.getValue(offset + 15);

		let a = H.getValue(0);
		let b = H.getValue(1);
		let c = H.getValue(2);
		let d = H.getValue(3);

		a = FF(a, b, c, d, M_offset_0, 7, T[0]);
		d = FF(d, a, b, c, M_offset_1, 12, T[1]);
		c = FF(c, d, a, b, M_offset_2, 17, T[2]);
		b = FF(b, c, d, a, M_offset_3, 22, T[3]);
		a = FF(a, b, c, d, M_offset_4, 7, T[4]);
		d = FF(d, a, b, c, M_offset_5, 12, T[5]);
		c = FF(c, d, a, b, M_offset_6, 17, T[6]);
		b = FF(b, c, d, a, M_offset_7, 22, T[7]);
		a = FF(a, b, c, d, M_offset_8, 7, T[8]);
		d = FF(d, a, b, c, M_offset_9, 12, T[9]);
		c = FF(c, d, a, b, M_offset_10, 17, T[10]);
		b = FF(b, c, d, a, M_offset_11, 22, T[11]);
		a = FF(a, b, c, d, M_offset_12, 7, T[12]);
		d = FF(d, a, b, c, M_offset_13, 12, T[13]);
		c = FF(c, d, a, b, M_offset_14, 17, T[14]);
		b = FF(b, c, d, a, M_offset_15, 22, T[15]);

		a = GG(a, b, c, d, M_offset_1, 5, T[16]);
		d = GG(d, a, b, c, M_offset_6, 9, T[17]);
		c = GG(c, d, a, b, M_offset_11, 14, T[18]);
		b = GG(b, c, d, a, M_offset_0, 20, T[19]);
		a = GG(a, b, c, d, M_offset_5, 5, T[20]);
		d = GG(d, a, b, c, M_offset_10, 9, T[21]);
		c = GG(c, d, a, b, M_offset_15, 14, T[22]);
		b = GG(b, c, d, a, M_offset_4, 20, T[23]);
		a = GG(a, b, c, d, M_offset_9, 5, T[24]);
		d = GG(d, a, b, c, M_offset_14, 9, T[25]);
		c = GG(c, d, a, b, M_offset_3, 14, T[26]);
		b = GG(b, c, d, a, M_offset_8, 20, T[27]);
		a = GG(a, b, c, d, M_offset_13, 5, T[28]);
		d = GG(d, a, b, c, M_offset_2, 9, T[29]);
		c = GG(c, d, a, b, M_offset_7, 14, T[30]);
		b = GG(b, c, d, a, M_offset_12, 20, T[31]);

		a = HH(a, b, c, d, M_offset_5, 4, T[32]);
		d = HH(d, a, b, c, M_offset_8, 11, T[33]);
		c = HH(c, d, a, b, M_offset_11, 16, T[34]);
		b = HH(b, c, d, a, M_offset_14, 23, T[35]);
		a = HH(a, b, c, d, M_offset_1, 4, T[36]);
		d = HH(d, a, b, c, M_offset_4, 11, T[37]);
		c = HH(c, d, a, b, M_offset_7, 16, T[38]);
		b = HH(b, c, d, a, M_offset_10, 23, T[39]);
		a = HH(a, b, c, d, M_offset_13, 4, T[40]);
		d = HH(d, a, b, c, M_offset_0, 11, T[41]);
		c = HH(c, d, a, b, M_offset_3, 16, T[42]);
		b = HH(b, c, d, a, M_offset_6, 23, T[43]);
		a = HH(a, b, c, d, M_offset_9, 4, T[44]);
		d = HH(d, a, b, c, M_offset_12, 11, T[45]);
		c = HH(c, d, a, b, M_offset_15, 16, T[46]);
		b = HH(b, c, d, a, M_offset_2, 23, T[47]);

		a = II(a, b, c, d, M_offset_0, 6, T[48]);
		d = II(d, a, b, c, M_offset_7, 10, T[49]);
		c = II(c, d, a, b, M_offset_14, 15, T[50]);
		b = II(b, c, d, a, M_offset_5, 21, T[51]);
		a = II(a, b, c, d, M_offset_12, 6, T[52]);
		d = II(d, a, b, c, M_offset_3, 10, T[53]);
		c = II(c, d, a, b, M_offset_10, 15, T[54]);
		b = II(b, c, d, a, M_offset_1, 21, T[55]);
		a = II(a, b, c, d, M_offset_8, 6, T[56]);
		d = II(d, a, b, c, M_offset_15, 10, T[57]);
		c = II(c, d, a, b, M_offset_6, 15, T[58]);
		b = II(b, c, d, a, M_offset_13, 21, T[59]);
		a = II(a, b, c, d, M_offset_4, 6, T[60]);
		d = II(d, a, b, c, M_offset_11, 10, T[61]);
		c = II(c, d, a, b, M_offset_2, 15, T[62]);
		b = II(b, c, d, a, M_offset_9, 21, T[63]);

		H.setValue(0, operationZero(H.getValue(0) + a))
		H.setValue(1, operationZero(H.getValue(1) + b))
		H.setValue(2, operationZero(H.getValue(2) + c))
		H.setValue(3, operationZero(H.getValue(3) + d))
	}
	_doFinalize() {
		const data = this._data;
		const dataWords = data.words;

		const nBitsTotal = this._nDataBytes * 8;
		const nBitsLeft = data.sigBytes * 8;

		dataWords.setValue(nBitsLeft >>> 5, dataWords.getValue(nBitsLeft >>> 5) | (0x80 << (24 - (nBitsLeft % 32))))

		const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
		const nBitsTotalL = nBitsTotal;
		const x = (((nBitsLeft + 64) >>> 9) << 4) + 15
		dataWords.setValue(x, ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)))
		const xx = (((nBitsLeft + 64) >>> 9) << 4) + 14
		dataWords.setValue(xx, ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)))
		data.sigBytes = (dataWords.length + 1) * 4;

		this._process();

		const hash = this._hash;
		const H = hash.words;

		for (let i = 0; i < 4; i += 1) {
			const H_i = H.getValue(i);
			H.setValue(i, (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00));
		}

		return hash;
	}

	_append(data : any) {
		let m_data : any = data;
		if (typeof m_data == 'string') {
			m_data = Utf8.parse(m_data);
		}
		this._data.concat(m_data as WordArray);
		this._nDataBytes += m_data.sigBytes;
	}
	_process() {
		const hasherBlockSize = this.blockSize;
		const dataWords = this._data.words;
		const dataSigBytes = this._data.sigBytes;
		const blockSizeBytes = hasherBlockSize * 4;

		let nBlocksReady = dataSigBytes / blockSizeBytes;
		nBlocksReady = Math.max(operationZero(nBlocksReady) - 0, 0);

		const nWordsReady = nBlocksReady * hasherBlockSize;

		const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

		if (nWordsReady > 0) {
			for (let offset = 0; offset < nWordsReady; offset += hasherBlockSize) {
				this._doProcessBlock(dataWords, offset);
			}
			this._data.sigBytes -= nBytesReady;
		}
	}
	reset() {
		this._data = new WordArray();
		this._nDataBytes = 0;
		this._doReset();
	}
	finalize(messageUpdate : any | null) : WordArray {
		if (messageUpdate != null && `${messageUpdate}` != '') {
			this._append(messageUpdate);
		}
		const hash = this._doFinalize();
		return hash;
	}
	update(messageUpdate:any) : MD5Algo {
		this._append(messageUpdate);
		this._process();
		return this;
	}
}

export function MD5(str : string) : string {
	const md5algo = new MD5Algo()
	const arr = md5algo.finalize(str)
	return Hex.stringify(arr)

}

export function HmacMD5(message : string, key : string) : string {
	const hasher = new MD5Algo()
	let _key = Utf8.parse(key)
	const hasherBlockSize = hasher.blockSize;
	const hasherBlockSizeBytes = hasherBlockSize * 4;
	if (_key.sigBytes > hasherBlockSizeBytes) {
		_key = hasher.finalize(key);
	}
	_key.clamp();
	const oKey = new WordArray();
	oKey.words = _key.words.copy()

	for (let i = 0; i < hasherBlockSize; i += 1) {
		oKey.words.setValue(i, oKey.words.getValue(i) ^ 0x5c5c5c5c)
		_key.words.setValue(i, _key.words.getValue(i) ^ 0x36363636)
	}
	oKey.sigBytes = hasherBlockSizeBytes;
	_key.sigBytes = hasherBlockSizeBytes;

	hasher.reset()

	hasher._data.concat(_key);
	hasher._nDataBytes += _key.sigBytes;

	hasher._process();

	const innerHash = hasher.finalize(message);
	hasher.reset()

	const cloneKey = new WordArray()
	cloneKey.words = oKey.words.copy()
	cloneKey.sigBytes = oKey.sigBytes
	const hmac = hasher.finalize(cloneKey.concat(innerHash));
	return Hex.stringify(hmac);
}