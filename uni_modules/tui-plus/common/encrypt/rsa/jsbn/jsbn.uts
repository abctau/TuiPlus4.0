import { cbit, int2char, lbit } from "./util";
import { TuiArray } from "../../core/array";
const dbits : number = 28;
const lowprimes : number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,
	103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,
	227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
	353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479,
	487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619,
	631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769,
	773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,
	937, 941, 947, 953, 967, 971, 977, 983, 991, 997
];
const lplim : number = (1 << 26) / lowprimes[lowprimes.length - 1];
const BI_FP = 52;
export class BigInteger {
	DB : number = dbits;
	DM : number = ((1 << dbits) - 1);
	DV : number = (1 << dbits);
	FV : number = Math.pow(2, BI_FP);
	F1 : number = BI_FP - dbits;
	F2 : number = 2 * dbits - BI_FP;
	s : number = -1
	t : number = -1
	arr : TuiArray = new TuiArray()
	constructor(a : any | null = null, b : number | null = null) {
		if (a != null) {
			if ("number" == typeof a) {
			} else if (b == null && "string" != typeof a) {
				this.fromString(a, 256);
			} else {
				this.fromString(a, b);
			}
		}
	}
	toString(b : number) : string {
		if (this.s < 0) {
			return "-" + this.negate().toString(b);
		}
		let k : number;
		if (b == 16) {
			k = 4;
		} else if (b == 8) {
			k = 3;
		} else if (b == 2) {
			k = 1;
		} else if (b == 32) {
			k = 5;
		} else if (b == 4) {
			k = 2;
		} else {
			return this.toRadix(b);
		}
		const km = (1 << k) - 1;
		let d : number;
		let m : boolean = false;
		let r : string = "";
		let i : number = this.t;
		let p = this.DB - (i * this.DB) % k;
		if (i-- > 0) {
			d = this.arr.getValue(i) >> p
			if (p < this.DB && d > 0) {
				m = true;
				r = int2char(d);
			}
			while (i >= 0) {
				if (p < k) {
					d = (this.arr.getValue(i) & ((1 << p) - 1)) << (k - p);
					p += this.DB - k
					d |= this.arr.getValue(--i) >> (p);
				} else {
					p -= k
					d = (this.arr.getValue(i) >> (p)) & km;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if (d > 0) {
					m = true;
				}
				if (m) {
					r += int2char(d);
				}
			}
		}
		return m ? r : "0";
	};
	negate() : BigInteger {
		let r = nbi();
		BigIntegerZERO.subTo(this, r);
		return r;
	};
	abs() : BigInteger {
		return (this.s < 0) ? this.negate() : this;
	};
	compareTo(a : BigInteger) : number {
		let r = this.s - a.s;
		if (r != 0) {
			return r;
		}
		let i = this.t;
		r = i - a.t;
		if (r != 0) {
			return (this.s < 0) ? -r : r;
		}
		while (--i >= 0) {
			r = this.arr.getValue(i) - a.arr.getValue(i)
			if ((r) != 0) {
				return r;
			}
		}
		return 0;
	};
	bitLength() : number {
		if (this.t <= 0) {
			return 0;
		}
		return this.DB * (this.t - 1) + nbits(this.arr.getValue(this.t - 1) ^ (this.s & this.DM));
	};
	mod(a : BigInteger) : BigInteger {
		const r = nbi();
		this.abs().divRemTo(a, null, r);
		if (this.s < 0 && r.compareTo(BigIntegerZERO) > 0) {
			a.subTo(r, r);
		}
		return r;
	};
	modPowInt(e : number, m : BigInteger) : BigInteger {
		let z : PublicBarrett;
		if (e < 256 || m.isEven()) {
			z = new Classic(m) as PublicBarrett;
		} else {
			z = new Montgomery(m) as PublicBarrett;
		}
		return this.exp(e, z);
	};
	clone() : BigInteger {
		let r = nbi();
		this.copyTo(r);
		return r;
	};
	intValue() : number {
		if (this.s < 0) {
			if (this.t == 1) {
				return this.arr.getValue(0) - this.DV;
			} else if (this.t == 0) {
				return -1;
			}
		} else if (this.t == 1) {
			return this.arr.getValue(0);
		} else if (this.t == 0) {
			return 0;
		}
		return ((this.arr.getValue(1) & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.arr.getValue(0);
	};
	byteValue() : number {
		return (this.t == 0) ? this.s : (this.arr.getValue(0) << 24) >> 24;
	};
	shortValue() : number {
		return (this.t == 0) ? this.s : (this.arr.getValue(0) << 16) >> 16;
	};
	signum() : number {
		if (this.s < 0) {
			return -1;
		} else if (this.t <= 0 || (this.t == 1 && this.arr.getValue(0) <= 0)) {
			return 0;
		} else {
			return 1;
		}
	};
	toByteArray() : number[] {
		let i = this.t;
		let r = new TuiArray();
		r.setValue(0, this.s);
		let p : number = this.DB - (i * this.DB) % 8;
		let d : number;
		let k : number = 0;
		if (i-- > 0) {
			d = this.arr.getValue(i) >> p
			if (p < this.DB && (d) != (this.s & this.DM) >> p) {
				r.setValue(k++, d | (this.s << (this.DB - p)))
			}
			while (i >= 0) {
				if (p < 8) {
					d = (this.arr.getValue(i) & ((1 << p) - 1)) << (8 - p);
					p += this.DB - 8
					d |= this.arr.getValue(--i) >> (p);
				} else {
					p -= 8
					d = (this.arr.getValue(i) >> (p)) & 0xff;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if ((d & 0x80) != 0) {
					d |= -256;
				}
				if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
					++k;
				}
				if (k > 0 || d != this.s) {
					r.setValue(k++, d)
				}
			}
		}
		return r;
	};
	equals(a : BigInteger) : boolean {
		return (this.compareTo(a) == 0);
	};
	min(a : BigInteger) : BigInteger {
		return (this.compareTo(a) < 0) ? this : a;
	};
	max(a : BigInteger) : BigInteger {
		return (this.compareTo(a) > 0) ? this : a;
	};
	not() : BigInteger {
		let r = nbi();
		for (let i = 0; i < this.t; ++i) {
			r.arr.setValue(i, this.DM & ~this.arr.getValue(i))
		}
		r.t = this.t;
		r.s = ~this.s;
		return r;
	};
	shiftLeft(n : number) : BigInteger {
		let r = nbi();
		if (n < 0) {
			this.rShiftTo(-n, r);
		} else {
			this.lShiftTo(n, r);
		}
		return r;
	};
	shiftRight(n : number) : BigInteger {
		let r = nbi();
		if (n < 0) {
			this.lShiftTo(-n, r);
		} else {
			this.rShiftTo(n, r);
		}
		return r;
	};
	getLowestSetBit() : number {
		for (let i = 0; i < this.t; ++i) {
			if (this.arr.getValue(i) != 0) {
				return i * this.DB + lbit(this.arr.getValue(i));
			}
		}
		if (this.s < 0) {
			return this.t * this.DB;
		}
		return -1;
	};
	bitCount() : number {
		let r = 0;
		let x = this.s & this.DM;
		for (let i = 0; i < this.t; ++i) {
			r += cbit(this.arr.getValue(i) ^ x);
		}
		return r;
	};
	testBit(n : number) : boolean {
		let j = Math.floor(n / this.DB);
		if (j >= this.t) {
			return (this.s != 0);
		}
		return ((this.arr.getValue(j) & (1 << (n % this.DB))) != 0);
	};
	add(a : BigInteger) : BigInteger {
		let r = nbi();
		this.addTo(a, r);
		return r;
	};
	subtract(a : BigInteger) : BigInteger {
		let r = nbi();
		this.subTo(a, r);
		return r;
	};
	multiply(a : BigInteger) : BigInteger {
		let r = nbi();
		this.multiplyTo(a, r);
		return r;
	};
	divide(a : BigInteger) : BigInteger {
		let r = nbi();
		this.divRemTo(a, r, null);
		return r;
	};
	remainder(a : BigInteger) : BigInteger {
		let r = nbi();
		this.divRemTo(a, null, r);
		return r;
	};
	divideAndRemainder(a : BigInteger) : BigInteger[] {
		let q = nbi();
		let r = nbi();
		this.divRemTo(a, q, r);
		return [q, r];
	};
	modPow(e : BigInteger, m : BigInteger) : BigInteger {
		let i = e.bitLength();
		let k : number;
		let r = nbv(1);
		let z : PublicBarrett;
		if (i <= 0) {
			return r;
		} else if (i < 18) {
			k = 1;
		} else if (i < 48) {
			k = 3;
		} else if (i < 144) {
			k = 4;
		} else if (i < 768) {
			k = 5;
		} else {
			k = 6;
		}
		if (i < 8) {
			z = new Classic(m);
		} else if (m.isEven()) {
			z = new Barrett(m);
		} else {
			z = new Montgomery(m);
		}
		let g = new Map<number, BigInteger>()
		let n = 3;
		let k1 = k - 1;
		let km = (1 << k) - 1;
		g.set(1, z.convert(this))
		if (k > 1) {
			let g2 = nbi();
			z.sqrTo(g.get(1)!, g2);
			while (n <= km) {
				g.set(n, nbi())
				z.mulTo(g2, g.get(n - 2)!, g.get(n)!);
				n += 2;
			}
		}
		let j = e.t - 1;
		let w : number;
		let is1 = true;
		let r2 = nbi();
		let t : BigInteger;
		i = nbits(e.arr.getValue(j)) - 1;
		let count = 0
		while (j >= 0) {
			count++
			if (i >= k1) {
				w = (e.arr.getValue(j) >> (i - k1)) & km;
			} else {
				w = (e.arr.getValue(j) & ((1 << (i + 1)) - 1)) << (k1 - i);
				if (j > 0) {
					w |= e.arr.getValue(j - 1) >> (this.DB + i - k1);
				}
			}
			n = k;
			while ((w & 1) == 0) {
				count++
				w >>= 1;
				--n;
			}
			i -= n
			if ((i) < 0) {
				i += this.DB;
				--j;
			}
			if (is1) {
				g.get(w)?.copyTo(r);
				is1 = false;
			} else {
				while (n > 1) {
					count++
					z.sqrTo(r, r2);
					z.sqrTo(r2, r);
					n -= 2;
				}
				if (n > 0) {
					z.sqrTo(r, r2);
				} else {
					t = r;
					r = r2;
					r2 = t;
				}
				z.mulTo(r2, g.get(w)!, r);
			}
			while (j >= 0 && (e.arr.getValue(j) & (1 << i)) == 0) {
				count++
				z.sqrTo(r, r2);
				t = r;
				r = r2;
				r2 = t;
				if (--i < 0) {
					i = this.DB - 1;
					--j;
				}
			}
		}
		// console.log(count, j, w, i)
		return z.revert(r);
	};
	modInverse(m : BigInteger) : BigInteger {
		let ac = m.isEven();
		if ((this.isEven() && ac) || m.signum() == 0) {
			return BigIntegerZERO;
		}
		let u = m.clone();
		let v = this.clone();
		let a = nbv(1);
		let b = nbv(0);
		let c = nbv(0);
		let d = nbv(1);
		while (u.signum() != 0) {
			while (u.isEven()) {
				u.rShiftTo(1, u);
				if (ac) {
					if (!a.isEven() || !b.isEven()) {
						a.addTo(this, a);
						b.subTo(m, b);
					}
					a.rShiftTo(1, a);
				} else if (!b.isEven()) {
					b.subTo(m, b);
				}
				b.rShiftTo(1, b);
			}
			while (v.isEven()) {
				v.rShiftTo(1, v);
				if (ac) {
					if (!c.isEven() || !d.isEven()) {
						c.addTo(this, c);
						d.subTo(m, d);
					}
					c.rShiftTo(1, c);
				} else if (!d.isEven()) {
					d.subTo(m, d);
				}
				d.rShiftTo(1, d);
			}
			if (u.compareTo(v) >= 0) {
				u.subTo(v, u);
				if (ac) {
					a.subTo(c, a);
				}
				b.subTo(d, b);
			} else {
				v.subTo(u, v);
				if (ac) {
					c.subTo(a, c);
				}
				d.subTo(b, d);
			}
		}
		if (v.compareTo(BigIntegerONE) != 0) {
			return BigIntegerZERO;
		}
		if (d.compareTo(m) >= 0) {
			return d.subtract(m);
		}
		if (d.signum() < 0) {
			d.addTo(m, d);
		} else {
			return d;
		}
		if (d.signum() < 0) {
			return d.add(m);
		} else {
			return d;
		}
	};
	pow(e : number) {
		return this.exp(e, new NullExp() as PublicBarrett);
	};
	gcd(a : BigInteger) : BigInteger {
		let x = (this.s < 0) ? this.negate() : this.clone();
		let y = (a.s < 0) ? a.negate() : a.clone();
		if (x.compareTo(y) < 0) {
			let t = x;
			x = y;
			y = t;
		}
		let i = x.getLowestSetBit();
		let g = y.getLowestSetBit();
		if (g < 0) {
			return x;
		}
		if (i < g) {
			g = i;
		}
		if (g > 0) {
			x.rShiftTo(g, x);
			y.rShiftTo(g, y);
		}
		while (x.signum() > 0) {
			i = x.getLowestSetBit()
			if ((i) > 0) {
				x.rShiftTo(i, x);
			}
			i = y.getLowestSetBit()
			if ((i) > 0) {
				y.rShiftTo(i, y);
			}
			if (x.compareTo(y) >= 0) {
				x.subTo(y, x);
				x.rShiftTo(1, x);
			} else {
				y.subTo(x, y);
				y.rShiftTo(1, y);
			}
		}
		if (g > 0) {
			y.lShiftTo(g, y);
		}
		return y;
	};
	isProbablePrime(t : number) : boolean {
		let i : number;
		let x : BigInteger = this.abs();
		if (x.t == 1 && x.arr.getValue(0) <= lowprimes[lowprimes.length - 1]) {
			for (i = 0; i < lowprimes.length; ++i) {
				if (x.arr.getValue(0) == lowprimes[i]) {
					return true;
				}
			}
			return false;
		}
		if (x.isEven()) {
			return false;
		}
		i = 1;
		while (i < lowprimes.length) {
			let m = lowprimes[i];
			let j = i + 1;
			while (j < lowprimes.length && m < lplim) {
				m *= lowprimes[j++];
			}
			m = x.modInt(m);
			while (i < j) {
				if (m % lowprimes[i++] == 0) {
					return false;
				}
			}
		}
		return x.millerRabin(t);
	};
	copyTo(r : BigInteger) {
		for (let i = this.t - 1; i >= 0; --i) {
			r.arr.setValue(i, this.arr.getValue(i))
		}
		r.t = this.t;
		r.s = this.s;
	};
	fromInt(x : number) {
		this.t = 1;
		this.s = (x < 0) ? -1 : 0;
		if (x > 0) {
			this.arr.setValue(0, x);
		} else if (x < -1) {
			this.arr.setValue(0, x + this.DV);
		} else {
			this.t = 0;
		}
	};
	formNumber(s : any, i : number) : number {
		let sn : number
		if (typeof s == 'string') {
			const catat : string = (`${s}`).charAt(i)
			sn = parseInt(catat)
		} else {
			sn = parseInt(`${(s as number[])[i]}`)
		}
		return sn
	}
	fromString(s : any, b : number | null) {
		let k : number;
		if (b == 16) {
			k = 4;
		} else if (b == 8) {
			k = 3;
		} else if (b == 256) {
			k = 8;
		} else if (b == 2) {
			k = 1;
		} else if (b == 32) {
			k = 5;
		} else if (b == 4) {
			k = 2;
		} else {
			this.fromRadix(`${s}`, b);
			return;
		}
		this.t = 0;
		this.s = 0;
		let i : number;
		if (typeof s == 'string') {
			i = (s as string).length
		} else {
			i = (s as number[]).length
		}
		let mi = false;
		let sh = 0;
		while (--i >= 0) {
			const sn = this.formNumber(s, i)
			let x = (k == 8) ? sn & 0xff : intAt(`${s}`, i);
			if (x < 0) {
				if ((s as string).charAt(i) == "-") {
					mi = true;
				}
				continue;
			}
			mi = false;
			if (sh == 0) {
				this.arr.setValue(this.t++, x);
			} else if (sh + k > this.DB) {
				this.arr.setValue(this.t - 1, this.arr.getValue(this.t - 1) | ((x & ((1 << (this.DB - sh)) - 1)) << sh))
				this.arr.setValue(this.t++, (x >> (this.DB - sh)))
			} else {
				this.arr.setValue(this.t - 1, this.arr.getValue(this.t - 1) | x << sh)
			}
			sh += k;
			if (sh >= this.DB) {
				sh -= this.DB;
			}
		}
		const sn0 = this.formNumber(s, 0)
		if (k == 8 && (sn0 & 0x80) != 0) {
			this.s = -1;
			if (sh > 0) {
				this.arr.setValue(this.t - 1, this.arr.getValue(this.t - 1) | (((1 << (this.DB - sh)) - 1) << sh))
			}
		}
		this.clamp();
		if (mi) {
			BigIntegerZERO.subTo(this, this);
		}
	};
	clamp() {
		let c = this.s & this.DM;
		while (this.t > 0 && this.arr.getValue(this.t - 1) == c) {
			--this.t;
		}
	};
	dlShiftTo(n : number, r : BigInteger) {
		for (let i = this.t - 1; i >= 0; --i) {
			r.arr.setValue(i + n, this.arr.getValue(i))
		}
		for (let i = n - 1; i >= 0; --i) {
			r.arr.setValue(i, 0)
		}
		r.t = this.t + n;
		r.s = this.s;
	};
	drShiftTo(n : number, r : BigInteger) {
		for (let i = n; i < this.t; ++i) {
			r.arr.setValue(i - n, this.arr.getValue(i))
		}
		r.t = Math.max(this.t - n, 0);
		r.s = this.s;
	};
	lShiftTo(n : number, r : BigInteger) {
		let bs = n % this.DB;
		let cbs = this.DB - bs;
		let bm = (1 << cbs) - 1;
		let ds = Math.floor(n / this.DB);
		let c = (this.s << bs) & this.DM;
		for (let i = this.t - 1; i >= 0; --i) {
			r.arr.setValue(i + ds + 1, (this.arr.getValue(i) >> cbs) | c)
			c = (this.arr.getValue(i) & bm) << bs;
		}
		for (let i = ds - 1; i >= 0; --i) {
			r.arr.setValue(i, 0)
		}
		r.arr.setValue(ds, c)
		r.t = this.t + ds + 1;
		r.s = this.s;
		r.clamp();
	};
	rShiftTo(n : number, r : BigInteger) {
		r.s = this.s;
		let ds = Math.floor(n / this.DB);
		if (ds >= this.t) {
			r.t = 0;
			return;
		}
		let bs = n % this.DB;
		let cbs = this.DB - bs;
		let bm = (1 << bs) - 1;
		r.arr.setValue(0, this.arr.getValue(ds) >> bs)
		for (let i = ds + 1; i < this.t; ++i) {
			r.arr.setValue(i - ds - 1, r.arr.getValue(i - ds - 1) | ((this.arr.getValue(i) & bm) << cbs))
			r.arr.setValue(i - ds, this.arr.getValue(i) >> bs)
		}
		if (bs > 0) {
			r.arr.setValue(this.t - ds - 1, r.arr.getValue(this.t - ds - 1) | ((this.s & bm) << cbs))
		}
		r.t = this.t - ds;
		r.clamp();
	};
	subTo(a : BigInteger, r : BigInteger) {
		let i = 0;
		let c = 0;
		let m = Math.min(a.t, this.t);
		while (i < m) {
			c += this.arr.getValue(i) - a.arr.getValue(i);
			r.arr.setValue(i++, c & this.DM)
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c -= a.s;
			while (i < this.t) {
				c += this.arr.getValue(i);
				r.arr.setValue(i++, c & this.DM);
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c -= a.arr.getValue(i);
				r.arr.setValue(i++, c & this.DM);
				c >>= this.DB;
			}
			c -= a.s;
		}
		r.s = (c < 0) ? -1 : 0;
		if (c < -1) {
			r.arr.setValue(i++, this.DV + c);
		} else if (c > 0) {
			r.arr.setValue(i++, c);
		}
		r.t = i;
		r.clamp();
	};
	multiplyTo(a : BigInteger, r : BigInteger) {
		let x = this.abs();
		let y = a.abs();
		let i = x.t;
		r.t = i + y.t;
		while (--i >= 0) {
			r.arr.setValue(i, 0);
		}
		for (i = 0; i < y.t; ++i) {
			r.arr.setValue(i + x.t, x.am(0, y.arr.getValue(i), r, i, 0, x.t));
		}
		r.s = 0;
		r.clamp();
		if (this.s != a.s) {
			BigIntegerZERO.subTo(r, r);
		}
	};
	squareTo(r : BigInteger) {
		let x : BigInteger = this.abs();
		let result = 2 * x.t;
		r.t = result;
		let i = r.t;
		while (--i >= 0) {
			r.arr.setValue(i, 0);
		}
		for (i = 0; i < x.t - 1; ++i) {
			let si : number = 2 * i
			let sii : number = 2 * x.arr.getValue(i)
			let siii : number = 2 * i + 1
			let c = x.am(i, x.arr.getValue(i), r, si, 0, 1);
			r.arr.setValue(i + x.t, r.arr.getValue(i + x.t) + (x.am(i + 1, sii, r, siii, c, x.t - i - 1)))
			if (r.arr.getValue(i + x.t) >= x.DV) {
				r.arr.setValue(i + x.t, r.arr.getValue(i + x.t) - x.DV)
				r.arr.setValue(i + x.t + 1, 1);
			}
		}
		if (r.t > 0) {
			let si = 2 * i
			r.arr.setValue(r.t - 1, r.arr.getValue(r.t - 1) + (x.am(i, x.arr.getValue(i), r, si, 0, 1)))
		}
		r.s = 0;
		r.clamp();
	};
	divRemTo(m : BigInteger, q : BigInteger | null, r : BigInteger | null) {
		let pm = m.abs();
		if (pm.t <= 0) {
			return;
		}
		let pt = this.abs();
		if (pt.t < pm.t) {
			if (q != null) {
				q.fromInt(0);
			}
			if (r != null) {
				this.copyTo(r);
			}
			return;
		}
		if (r == null) {
			r = nbi();
		}
		let y = nbi();
		let ts = this.s;
		let ms = m.s;
		let nsh = this.DB - nbits(pm.arr.getValue(pm.t - 1));
		if (nsh > 0) {
			pm.lShiftTo(nsh, y);
			pt.lShiftTo(nsh, r);
		} else {
			pm.copyTo(y);
			pt.copyTo(r);
		}
		let ys = y.t;
		let y0 = y.arr.getValue(ys - 1);
		if (y0 == 0) {
			return;
		}
		let yt = y0 * (1 << this.F1) + ((ys > 1) ? y.arr.getValue(ys - 2) >> this.F2 : 0);
		let d1 = this.FV / yt;
		let d2 = (1 << this.F1) / yt;
		let e = 1 << this.F2;
		let i = r.t;
		let j = i - ys;
		let t = (q == null) ? nbi() : q;
		y.dlShiftTo(j, t);
		if (r.compareTo(t) >= 0) {
			r.arr.setValue(r.t++, 1);
			r.subTo(t, r);
		}
		BigIntegerONE.dlShiftTo(ys, t);
		t.subTo(y, y);
		while (y.t < ys) {
			y.arr.setValue(y.t++, 0);
		}
		while (--j >= 0) {
			let qd = (r.arr.getValue(--i) == y0) ? this.DM : Math.floor(r.arr.getValue(i) * d1 + (r.arr.getValue(i - 1) + e) * d2);
			r.arr.setValue(i, r.arr.getValue(i) + y.am(0, qd, r, j, 0, ys))
			if (r.arr.getValue(i) < qd) {
				y.dlShiftTo(j, t);
				r.subTo(t, r);
				while (r.arr.getValue(i) < --qd) {
					r.subTo(t, r);
				}
			}
		}
		if (q != null) {
			r.drShiftTo(ys, q);
			if (ts != ms) {
				BigIntegerZERO.subTo(q, q);
			}
		}
		r.t = ys;
		r.clamp();
		if (nsh > 0) {
			r.rShiftTo(nsh, r);
		}
		if (ts < 0) {
			BigIntegerZERO.subTo(r, r);
		}
	};

	invDigit() : number {
		if (this.t < 1) {
			return 0;
		}
		let x = this.arr.getValue(0);
		if ((x & 1) == 0) {
			return 0;
		}
		let y = x & 3;
		y = (y * (2 - (x & 0xf) * y)) & 0xf;
		y = (y * (2 - (x & 0xff) * y)) & 0xff;
		y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
		y = (y * (2 - x * y % this.DV)) % this.DV;
		return (y > 0) ? this.DV - y : -y;
	};
	isEven() : boolean {
		return ((this.t > 0) ? (this.arr.getValue(0) & 1) : this.s) == 0;
	};
	exp(e : number, z : PublicBarrett) : BigInteger {
		if (e > 0xffffffff || e < 1) {
			return BigIntegerONE;
		}
		let r = nbi();
		let r2 = nbi();
		let g = z.convert(this);
		let i = nbits(e) - 1;
		g.copyTo(r);
		while (--i >= 0) {
			z.sqrTo(r, r2);
			if ((e & (1 << i)) > 0) {
				z.mulTo(r2, g, r);
			} else {
				let t = r;
				r = r2;
				r2 = t;
			}
		}
		return z.revert(r);
	};
	chunkSize(r : number) {
		return Math.floor(Math.LN2 * this.DB / Math.log(r));
	};
	toRadix(b : number | null) : string {
		if (b == null) {
			b = 10;
		}
		if (this.signum() == 0 || b < 2 || b > 36) {
			return "0";
		}
		let cs = this.chunkSize(b);
		let a = Math.pow(b, cs);
		let d = nbv(a);
		let y = nbi();
		let z = nbi();
		let r = "";
		this.divRemTo(d, y, z);
		while (y.signum() > 0) {
			let str : string = (a + z.intValue()).toString(b)
			r = str.substring(1) + r;
			y.divRemTo(d, y, z);
		}
		return z.intValue().toString(b) + r;
	};
	fromRadix(s : string, b : number | null) {
		this.fromInt(0);
		if (b == null) {
			b = 10;
		}
		let cs = this.chunkSize(b);
		let d = Math.pow(b, cs);
		let mi = false;
		let j = 0;
		let w = 0;
		for (let i = 0; i < s.length; ++i) {
			let x = intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-" && this.signum() == 0) {
					mi = true;
				}
				continue;
			}
			w = b * w + x;
			if (++j >= cs) {
				this.dMultiply(d);
				this.dAddOffset(w, 0);
				j = 0;
				w = 0;
			}
		}
		if (j > 0) {
			this.dMultiply(Math.pow(b, j));
			this.dAddOffset(w, 0);
		}
		if (mi) {
			BigIntegerZERO.subTo(this, this);
		}
	};
	bitwiseTo(a : BigInteger, op : (x : number, y : number) => number, r : BigInteger) {
		let i : number;
		let f : number;
		let m : number = Math.min(a.t, this.t);
		for (i = 0; i < m; ++i) {
			r.arr.setValue(i, op(this.arr.getValue(i), a.arr.getValue(i)));
		}
		if (a.t < this.t) {
			f = a.s & this.DM;
			for (i = m; i < this.t; ++i) {
				r.arr.setValue(i, op(this.arr.getValue(i), f));
			}
			r.t = this.t;
		}
		else {
			f = this.s & this.DM;
			for (i = m; i < a.t; ++i) {
				r.arr.setValue(i, op(f, a.arr.getValue(i)));
			}
			r.t = a.t;
		}
		r.s = op(this.s, a.s);
		r.clamp();
	};
	addTo(a : BigInteger, r : BigInteger) {
		let i = 0;
		let c = 0;
		let m = Math.min(a.t, this.t);
		while (i < m) {
			c += this.arr.getValue(i) + a.arr.getValue(i);
			r.arr.setValue(i++, c & this.DM);
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c += a.s;
			while (i < this.t) {
				c += this.arr.getValue(i);
				r.arr.setValue(i++, c & this.DM);
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c += a.arr.getValue(i);
				r.arr.setValue(i++, c & this.DM);
				c >>= this.DB;
			}
			c += a.s;
		}
		r.s = (c < 0) ? -1 : 0;
		if (c > 0) {
			r.arr.setValue(i++, c);
		} else if (c < -1) {
			r.arr.setValue(i++, this.DV + c);
		}
		r.t = i;
		r.clamp();
	};
	dMultiply(n : number) {
		this.arr.setValue(this.t, this.am(0, n - 1, this, 0, 0, this.t));
		++this.t;
		this.clamp();
	};
	dAddOffset(n : number, _w : number) {
		let w : number = _w
		if (n == 0) {
			return;
		}
		while (this.t <= w) {
			this.arr.setValue(this.t++, 0);
		}
		this.arr.setValue(w, this.arr.getValue(w) + n);

		while (this.arr.getValue(w) >= this.DV) {
			this.arr.setValue(w, this.arr.getValue(w) - this.DV);
			if (++w >= this.t) {
				this.arr.setValue(this.t++, 0);
			}
			this.arr.setValue(w, this.arr.getValue(w) + 1);
		}
	};
	multiplyLowerTo(a : BigInteger, n : number, r : BigInteger) {
		let i = Math.min(this.t + a.t, n);
		r.s = 0;
		r.t = i;
		while (i > 0) {
			r.arr.setValue(--i, 0);
		}
		for (let j = r.t - this.t; i < j; ++i) {
			r.arr.setValue(i + this.t, this.am(0, a.arr.getValue(i), r, i, 0, this.t));
		}
		for (let j = Math.min(a.t, n); i < j; ++i) {
			this.am(0, a.arr.getValue(i), r, i, 0, n - i);
		}
		r.clamp();
	};
	multiplyUpperTo(a : BigInteger, _n : number, r : BigInteger) {
		let n : number = _n
		--n;
		let result = this.t + a.t - n;
		r.t = result;
		let i = r.t;
		r.s = 0;
		while (--i >= 0) {
			r.arr.setValue(i, 0);
		}
		for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
			let ti : number = parseInt(`${this.t}`) + i - n
			r.arr.setValue(ti, this.am(n - i, a.arr.getValue(i), r, 0, 0, ti));
		}
		r.clamp();
		r.drShiftTo(1, r);
	};
	modInt(n : number) : number {
		if (n <= 0) {
			return 0;
		}
		let d = this.DV % n;
		let r = (this.s < 0) ? n - 1 : 0;
		if (this.t > 0) {
			if (d == 0) {
				r = this.arr.getValue(0) % n;
			} else {
				for (let i = this.t - 1; i >= 0; --i) {
					r = (d * r + this.arr.getValue(i)) % n;
				}
			}
		}
		return r;
	};
	millerRabin(t : number) : boolean {
		let n1 = this.subtract(BigIntegerONE);
		let k = n1.getLowestSetBit();
		if (k <= 0) {
			return false;
		}
		let r = n1.shiftRight(k);
		t = (t + 1) >> 1;
		if (t > lowprimes.length) {
			t = lowprimes.length;
		}
		let a = nbi();
		for (let i = 0; i < t; ++i) {
			a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
			let y = a.modPow(r, this);
			console.log(y)
			if (y.compareTo(BigIntegerONE) != 0 && y.compareTo(n1) != 0) {
				let j = 1;
				while (j++ < k && y.compareTo(n1) != 0) {
					y = y.modPowInt(2, this);
					if (y.compareTo(BigIntegerONE) == 0) {
						return false;
					}
				}
				if (y.compareTo(n1) != 0) {
					return false;
				}
			}
		}
		return true;
	};
	square() {
		let r = nbi();
		this.squareTo(r);
		return r;
	};
	am(_i : number, x : number, w : BigInteger, _j : number, c : number, _n : number) : number {
		let j : number = _j
		let i : number = _i
		let n : number = _n
		let xl = x & 0x3fff;
		let xh = x >> 14;
		while (--n >= 0) {
			let l = this.arr.getValue(i) & 0x3fff;
			let h = this.arr.getValue(i++) >> 14;
			let m = xh * l + h * xl;
			l = xl * l + ((m & 0x3fff) << 14) + w.arr.getValue(j) + c;
			c = (l >> 28) + (m >> 14) + xh * h;
			w.arr.setValue(j++, l & 0xfffffff);
		}
		return c;
	}
}
interface PublicBarrett {
	convert(x : BigInteger) : BigInteger;
	revert(x : BigInteger) : BigInteger;
	reduce(x : BigInteger) : void;
	mulTo(x : BigInteger, y : BigInteger, r : BigInteger) : void;
	sqrTo(x : BigInteger, r : BigInteger) : void;
}
class NullExp implements PublicBarrett {
	constructor() { }

	convert(x : BigInteger) {
		return x;
	}
	revert(x : BigInteger) : BigInteger {
		return x;
	}
	reduce(x : BigInteger) { }
	mulTo(x : BigInteger, y : BigInteger, r : BigInteger) {
		x.multiplyTo(y, r);
	}

	sqrTo(x : BigInteger, r : BigInteger) {
		x.squareTo(r);
	}
}

class Classic implements PublicBarrett {
	m : BigInteger
	constructor(m : BigInteger) {
		this.m = m;
	}
	convert(x : BigInteger) {
		if (x.s < 0 || x.compareTo(this.m) >= 0) {
			return x.mod(this.m);
		} else {
			return x;
		}
	}
	revert(x : BigInteger) : BigInteger {
		return x;
	}
	reduce(x : BigInteger) {
		x.divRemTo(this.m, null, x);
	}
	mulTo(x : BigInteger, y : BigInteger, r : BigInteger) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	sqrTo(x : BigInteger, r : BigInteger) {
		x.squareTo(r);
		this.reduce(r);
	}
}

class Montgomery implements PublicBarrett {
	m : BigInteger
	mp : number
	mpl : number
	mph : number
	um : number
	mt2 : number
	constructor(m : BigInteger) {
		this.m = m;
		this.mp = m.invDigit();
		this.mpl = this.mp & 0x7fff;
		this.mph = this.mp >> 15;
		this.um = (1 << (m.DB - 15)) - 1;
		this.mt2 = 2 * m.t;
	}
	convert(x : BigInteger) {
		let r = nbi();
		x.abs().dlShiftTo(this.m.t, r);
		r.divRemTo(this.m, null, r);
		if (x.s < 0 && r.compareTo(BigIntegerZERO) > 0) {
			this.m.subTo(r, r);
		}
		return r;
	}
	revert(x : BigInteger) : BigInteger {
		let r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	}
	reduce(x : BigInteger) {
		while (x.t <= this.mt2) {
			// pad x so am has enough room later
			x.arr.setValue(x.t++, 0);
		}
		for (let i = 0; i < this.m.t; ++i) {
			let j = x.arr.getValue(i) & 0x7fff;
			let u0 = (j * this.mpl + (((j * this.mph + (x.arr.getValue(i) >> 15) * this.mpl) & this.um) << 15)) & x.DM;
			j = i + this.m.t;
			x.arr.setValue(j, x.arr.getValue(j) + (this.m.am(0, u0, x, i, 0, this.m.t)));
			while (x.arr.getValue(j) >= x.DV) {
				x.arr.setValue(j, x.arr.getValue(j) - x.DV)
				x.arr.setValue(++j, x.arr.getValue(j) + 1)
			}
		}
		x.clamp();
		x.drShiftTo(this.m.t, x);
		if (x.compareTo(this.m) >= 0) {
			x.subTo(this.m, x);
		}
	}

	mulTo(x : BigInteger, y : BigInteger, r : BigInteger) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	sqrTo(x : BigInteger, r : BigInteger) {
		x.squareTo(r);
		this.reduce(r);
	}
}

class Barrett implements PublicBarrett {
	m : BigInteger
	r2 : BigInteger
	q3 : BigInteger
	mu : BigInteger
	constructor(m : BigInteger) {
		this.m = m;
		this.r2 = nbi();
		this.q3 = nbi();
		BigIntegerONE.dlShiftTo(2 * m.t, this.r2);
		this.mu = this.r2.divide(m);
	}
	convert(x : BigInteger) {
		if (x.s < 0 || x.t > 2 * this.m.t) {
			return x.mod(this.m);
		} else if (x.compareTo(this.m) < 0) {
			return x;
		} else {
			const r = nbi();
			x.copyTo(r);
			this.reduce(r);
			return r;
		}
	}
	revert(x : BigInteger) : BigInteger {
		return x;
	}
	reduce(x : BigInteger) {
		x.drShiftTo(this.m.t - 1, this.r2);
		if (x.t > this.m.t + 1) {
			x.t = this.m.t + 1;
			x.clamp();
		}
		this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
		this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
		while (x.compareTo(this.r2) < 0) {
			x.dAddOffset(1, this.m.t + 1);
		}
		x.subTo(this.r2, x);
		while (x.compareTo(this.m) >= 0) {
			x.subTo(this.m, x);
		}
	}

	mulTo(x : BigInteger, y : BigInteger, r : BigInteger) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	sqrTo(x : BigInteger, r : BigInteger) {
		x.squareTo(r);
		this.reduce(r);
	}
}
export function nbi() : BigInteger { return new BigInteger(null); }
export function parseBigInt(str : any | null, r : number | null) : BigInteger {
	return new BigInteger(str, r);
}
const BI_RC = new TuiArray();
let rr : number = "0".charCodeAt(0)!
let vv : number;
for (vv = 0; vv <= 9; ++vv) {
	BI_RC.setValue(rr++, vv);
}
rr = "a".charCodeAt(0)!;
for (vv = 10; vv < 36; ++vv) {
	BI_RC.setValue(rr++, vv);
}
rr = "A".charCodeAt(0)!;
for (vv = 10; vv < 36; ++vv) {
	BI_RC.setValue(rr++, vv);;
}
export function intAt(s : string, i : number) : number {
	const c : number = BI_RC.getValue(s.charCodeAt(i)!);
	return c
}
export function nbv(i : number) : BigInteger {
	const r = nbi();
	r.fromInt(i);
	return r;
}
export function nbits(_x : number) : number {
	let x : number = _x
	let r = 1;
	let t : number;
	t = x >>> 16
	if ((t) != 0) {
		x = t;
		r += 16;
	}
	t = x >> 8
	if ((t) != 0) {
		x = t;
		r += 8;
	}
	t = x >> 4
	if ((t) != 0) {
		x = t;
		r += 4;
	}
	t = x >> 2
	if ((t) != 0) {
		x = t;
		r += 2;
	}
	t = x >> 1
	if ((t) != 0) {
		// x = t;
		r += 1;
	}
	return r;
}
const BigIntegerZERO = nbv(0);
const BigIntegerONE = nbv(1);