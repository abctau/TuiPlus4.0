import { TuiArray } from "../../core/array";
import { BigInteger, parseBigInt } from "./jsbn";
import { SecureRandom } from "./rng";

function pkcs1pad2(s : string, _n : number) : BigInteger | null {
	let n : number = _n
	if (n < s.length + 11) {
		console.error("Message too long for RSA");
		return null;
	}
	let ba = new TuiArray();
	let i = s.length - 1;
	while (i >= 0 && n > 0) {
		let c = s.charCodeAt(i--)!;
		if (c < 128) {
			ba.setValue(--n, c);
		} else if ((c > 127) && (c < 2048)) {
			ba.setValue(--n, (c & 63) | 128);
			ba.setValue(--n, (c >> 6) | 192);
		} else {
			ba.setValue(--n, (c & 63) | 128);
			ba.setValue(--n, ((c >> 6) & 63) | 128);
			ba.setValue(--n, (c >> 12) | 224);
		}
	}
	ba.setValue(--n, 0);
	let rng = new SecureRandom();
	let x = new TuiArray();
	while (n > 2) {
		x.setValue(0, 0);
		while (x.getValue(0) == 0) {
			rng.nextBytes(x);
		}
		ba.setValue(--n, x.getValue(0));
	}
	ba.setValue(--n, 2);
	ba.setValue(--n, 0);
	return new BigInteger(ba);
}

export class RSAKey {
	n : BigInteger = new BigInteger();
	e : number = 0;
	d : BigInteger = new BigInteger();
	p : BigInteger = new BigInteger();
	q : BigInteger = new BigInteger();
	dmp1 : BigInteger = new BigInteger();
	dmq1 : BigInteger = new BigInteger();
	coeff : BigInteger = new BigInteger();
	constructor() {

	}
	doPublic(x : BigInteger) {
		return x.modPowInt(this.e, this.n);
	}

	doPrivate(x : BigInteger) {
		// if (this.p == null || this.q == null) {
		// 	return x.modPow(this.d, this.n);
		// }
		let xp = x.mod(this.p).modPow(this.dmp1, this.p);
		let xq = x.mod(this.q).modPow(this.dmq1, this.q);
		while (xp.compareTo(xq) < 0) {
			xp = xp.add(this.p);
		}
		return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
	}
	encrypt(text : string) : string {
		let maxLength = (this.n.bitLength() + 7) >> 3;
		let m = pkcs1pad2(text, maxLength);
		if (m == null) {
			return '加密字符串超过RSA长度限制';
		}
		let c = this.doPublic(m);
		// if (c == null) {
		// 	return '加密字符串超过RSA长度限制';
		// }
		let h = c.toString(16);
		let length = h.length;
		for (let i = 0; i < maxLength * 2 - length; i++) {
			h = "0" + h;
		}
		return h;
	}

	decrypt(ctext : any) : string {
		let c = parseBigInt(ctext, 16);
		let m = this.doPrivate(c);
		// if (m == null) {
		// 	return '解密字符串超过RSA长度限制';
		// }
		return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
	}
}

function pkcs1unpad2(d : BigInteger, n : number) : string {
	let b = d.toByteArray();
	let i = 0;
	while (i < b.length && b[i] == 0) {
		++i;
	}
	if (b.length - i != n - 1 || b[i] != 2) {
		return '解密字符串超过RSA长度限制';
	}
	++i;
	while (b[i] != 0) {
		if (++i >= b.length) {
			return '解密字符串超过RSA长度限制';
		}
	}
	let ret = "";
	while (++i < b.length) {
		let c = b[i] & 255;
		if (c < 128) { // utf-8 decode
			ret += String.fromCharCode(c);
		} else if ((c > 191) && (c < 224)) {
			ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
			++i;
		} else {
			ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
			i += 2;
		}
	}
	return ret;
}