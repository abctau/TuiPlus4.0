<template>
	<t-view v-bind="extendsAttrs" :main-class="`fl fww ${mainClass}`" @click="mainOnclick" @initFinished="initFinished">
		<template v-if="mode=='light'">
			<text v-for="(item,index) in lightAttrs" :key="index"
				:style="[themeColor,themeFontSize,textMainStyle,extendsTextStyle,item.isHeightLight?`color: ${patternsColor};`:'']">
				{{item.text}}
			</text>
		</template>
		<template v-else>
			<!-- #ifdef MP-WEIXIN -->
			<view :style="[themeColor,themeFontSize,textMainStyle,extendsTextStyle,'width:100%;']">
				<slot>
					{{textFormat}}
				</slot>
			</view>
			<!-- #endif -->
			<!-- #ifndef MP-WEIXIN -->
			<text :style="[themeColor,themeFontSize,textMainStyle,extendsTextStyle,'width:100%;']">
				<slot>
					{{textFormat}}
				</slot>
			</text>
			<!-- #endif -->
		</template>
	</t-view>
</template>

<script setup>
	/**
	 * Text 文本
	 * @date 2025-05-31 12:08:06
	 * @author TanYuan
	 * @description 支持日期格式化,敏感信息隐藏,金额格式化处理,高亮文本显示,且支持插槽高亮显示
	 * @example /pagesA/basics/text/text
	 * @tutorial https://life.yundie.xyz/tui3.0/docs/component/t-text.html
	 * @example /pagesA/basics/text/text
	 * @property {String} size=[large|medium|small|mini] 组件尺寸(默认：mini)
	 * @value large 大尺寸，按钮的尺寸较大，适用于需要强调操作或易于点击的区域。
	 * @value medium 中尺寸，按钮的尺寸适中，可能是默认尺寸，适用于大多数场景。
	 * @value small 小尺寸，按钮的尺寸较小，适用于空间有限或操作不是特别重要的区域。
	 * @value mini 迷你，按钮的尺寸最小，适用于紧凑布局或辅助操作。
	 * @property {String} type=[info|primary|error|warning|success] 组件类型(默认：p)
	 * @value info 信息提示场景，通常用于提供一般的通知信息，不涉及特别的重要性或紧急性。
	 * @value primary 正常使用场景，可能用于强调某些主要的操作或信息，比如主要的按钮或导航链接。
	 * @value error 错误提示场景，用于指示出现了错误或问题，需要用户的注意。
	 * @value warning 警告提示场景，用于提示用户关于潜在的问题或需要注意的事项。
	 * @value success 成功提示场景，用于指示一个操作或过程已经成功完成。
	 * @property {Boolean} disabled=[false|true] 组件是否禁用
	 * @property {Boolean} stop=[false|true] 是否阻止事件冒泡（Tui统一写法处理事件冒泡）(默认: false)
	 * @property {Boolean} hover=[false|true] 是否有点击效果(默认：true)
	 * @property {String} path 点击组件后跳转的页面路径，如果为空则响应点击事件，如果不为空则跳转页面不会响应单击事件。(默认: "")
	 * @property {String} mainClass 组件根节点的样式。(默认: "")
	 * @property {String} nativeClass 组件根节点原生样式。(默认: "")
	 * @property {String} effect=[normal|dark|light|plain] 组件显示主题(默认：plain)
	 * @value normal 正常
	 * @value dark 深色
	 * @value light 浅色
	 * @value plain 镂空
	 * @property {String} mode=[default|date|price|sensitive|light] 字符串格式化处理方式(默认：default)
	 * @value default 默认不处理
	 * @value date 处理为日期格式。配合format一起使用
	 * @value price 格式化为金额显示
	 * @value sensitive 隐藏敏感信息
	 * @value light 部分文本高亮显示
	 * @property {String} format mode=='date' 日期格式化格式(默认：yyyy-mm-dd hh:MM:ss)
	 * @property {Number} decimals 金额显示时显示小数点的位数(默认：1)
	 * @property {Number} lines 文本显示和行数，超出就会隐藏(默认：1)
	 * @property {String} decimalPoint 金额表示符文本(默认：￥)
	 * @property {Boolean} overflow 是否允许文本溢出
	 * @value true 是
	 * @value false 否
	 * @property {any} patternsValue 需要高亮显示文本的内容。(默认：[])
	 * @property {any} patternsReg 自定义匹配高亮正则表达
	 * @property {String} patternsColor 匹配高亮显示的文本(默认：#ff0000)
	 * @property {String} text 显示的文本
	 * @event {Function} click 点击时触发
	 */
	import { timeFormat, priceFormat, sensitiveWordFilter, parseTimeData } from '../../common/model/formart'
	import { isNumber } from '../../common/model/test'
	import { useStyle } from '../../common/model/style'
	import { CommonProps, useTuiThemes } from '../../common/props/index.uts';
	type TypeChildText = {
		text : string,
		color : string,
		isHeightLight : boolean
	}
	interface TextProps extends CommonProps {
		mode : string
		format : string
		decimals : number
		lines : number
		decimalPoint : string
		overflow : boolean
		patternsValue : string[]
		patternsReg : string[]
		patternsColor : string
		text : string
	}
	const props = withDefaults(defineProps<TextProps>(), {
		path: '',
		hover: false,
		type: '',
		disabled: false,
		stop: false,
		effect: '',
		size: '',
		mainClass: '',
		nativeClass: '',
		mode: 'default',
		format: 'yyyy-mm-dd hh:MM:ss',
		decimals: 0,
		lines: -1,
		decimalPoint: '￥',
		overflow: false,
		patternsValue: [] as string[],
		patternsReg: [] as string[],
		patternsColor: '#ff0000',
		text: ''
	});
	const { extendsAttrs, themeColor, themeFontSize, extendsTextStyle } = useTuiThemes(props)
	const emit = defineEmits(['click', 'initFinished'])
	function mainOnclick(e : UniPointerEvent) {
		if (props.stop) e.stopPropagation()
		if (props.path != '') {
			uni.navigateTo({
				url: props.path,
				fail: (_) => {
					uni.switchTab({
						url: props.path
					})
				}
			})
		} else {
			emit('click', e)
		}
	}
	function initFinished(rect : NodeInfo) {
		emit('initFinished', rect)
	}
	function getLightAttrs(label : string) : TypeChildText[] {
		let ar = [] as TypeChildText[]
		try {
			let keywords = props.patternsValue
			if ((keywords.length == 0 && props.patternsReg.length == 0) || label.length == 0) {
				return [{ text: label, color: '#333', isHeightLight: false } as TypeChildText]
			}
			let regexxAr = [] as string[];

			props.patternsReg.forEach(function (reg : string) {
				let regex = new RegExp(reg, 'gi');
				let rulst = regex.exec(label)
				if (Array.isArray(rulst)) {
					regexxAr = regexxAr.concat(rulst as string[]) as string[]
				}
			});
			keywords = keywords.concat(regexxAr)
			keywords.forEach(function (keyword : string) {
				let regex = new RegExp(keyword, 'gi');
				label = label.replace(regex, `~-<span>${keyword}</span>~-`);
			});
			let ps = label.split('~-')
			ps.forEach((el : string) => {
				if (el.length > 0) {
					let start = el.indexOf('<span>')
					if (start > -1) {
						let end = el.lastIndexOf('</span>')
						ar.push({
							text: el.substring(start + 6, end),
							color: props.patternsColor,
							isHeightLight: true
						} as TypeChildText)
					} else {
						ar.push({
							text: el,
							color: '#333',
							isHeightLight: false
						} as TypeChildText)
					}
				}
			})

		} catch (error) {

		}
		return ar;
	}

	const lightAttrs = computed(() : TypeChildText[] => {
		const narr : TypeChildText[] = []
		const arr = getLightAttrs(props.text)
		arr.forEach((item : TypeChildText) => {
			const textArr : string[] = item.text.split('')
			textArr.forEach((k : string) => {
				narr.push({
					text: k,
					color: item.color,
					isHeightLight: item.isHeightLight
				})
			})
		})
		return narr
	})
	const textMainStyle = computed(() : string => {
		let sty : string = ' '
		if (props.lines > 0) sty += `l-${props.lines} `
		if (props.overflow) sty += 'sto-e oh'
		return useStyle(sty)
	})

	const textFormat = computed(() : string => {
		let txtval = props.text
		switch (props.mode) {
			case 'date':
				txtval = timeFormat(txtval, props.format)
				break;
			case 'time':
				if (isNumber(txtval)) txtval = parseTimeData(parseInt(txtval), props.format)
				break;
			case 'price':
				txtval = priceFormat(txtval, props.decimals, ',', props.decimalPoint)
				break;
			case 'sensitive':
				txtval = sensitiveWordFilter(txtval)
				break;
			default:
				break;
		}
		return txtval
	})
</script>