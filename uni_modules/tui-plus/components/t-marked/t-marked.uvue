<template>
	<t-view v-bind="extendsAttrs">
		<template v-for="(items,boxi) in treeList" :key="`box${boxi}`">
			<template v-for="(tokens,listi) in items" :key="`list${listi}`">
				<t-marked-code v-if="tokens[0].type=='code'" v-for="token in tokens" :codeText="token.text"
					main-class="mb-30" :language="tokens[0].lang"></t-marked-code>
				<view v-else-if="tokens[0]?.type == 'hr'" v-for="(token,hri) in tokens" :key="`hr${hri}`" class="hr">hr
				</view>
				<template v-else-if="tokens[0]?.type == 'table'" v-for="(token,tablei) in tokens"
					:key="`table${tablei}`">
					<t-scroll direction="horizontal" main-class="mb-30">
						<t-marked-table align="center" main-class="tdr" :stripe="true" :border="true">
							<t-marked-tr>
								<t-marked-th v-for="(item,thi) in token.header"
									:key="`th${thi}`">{{item['text']}}</t-marked-th>
							</t-marked-tr>
							<t-marked-tr v-for="(trItem,rwi) in token.rows" :key="`rw${rwi}`">
								<t-marked-td v-for="(td,tdi) in trItem" :key="`td${tdi}`">{{ td['text'] }}</t-marked-td>
							</t-marked-tr>
						</t-marked-table>
					</t-scroll>
				</template>
				<image v-else-if="tokens[0]?.type == 'image'" v-for="(token,imagei) in tokens" :key="`image${imagei}`"
					mode="widthFix" style="width: 100%;" :src="token.href"></image>
				<text v-else :decode="true" class="text">
					<text v-for="(token,texti) in tokens" :key="`texti${texti}`" :class="token.class ?? ''"
						:decode="true">{{token.text}}</text>
				</text>
			</template>
		</template>
	</t-view>
</template>

<script setup>	/**
	 * Marked 富文本
	 * @date 2025-08-14 19:33:36
	 * @author TanYuan
	 * @description 原生组件实现，非webview套壳。从uni-ai x中分离出来的，
	 * @example /pagesA/layout/markdown/markdown.uvue
	 * @tutorial https://life.yundie.xyz/tui3.0/docs/component/t-marked.html
	 * @example /pagesA/layout/markdown/markdown.uvue
	 * @property {String} size=[large|medium|small|mini] 组件尺寸 (默认:medium)
	 * @value large 大尺寸，按钮的尺寸较大，适用于需要强调操作或易于点击的区域。
	 * @value medium 中尺寸，按钮的尺寸适中，可能是默认尺寸，适用于大多数场景。
	 * @value small 小尺寸，按钮的尺寸较小，适用于空间有限或操作不是特别重要的区域。
	 * @value mini 迷你，按钮的尺寸最小，适用于紧凑布局或辅助操作。
	 * @property {String} type=[info|primary|error|warning|success] 组件类型 (默认: "")
	 * @value info 信息提示场景，通常用于提供一般的通知信息，不涉及特别的重要性或紧急性。
	 * @value primary 正常使用场景，可能用于强调某些主要的操作或信息，比如主要的按钮或导航链接。
	 * @value error 错误提示场景，用于指示出现了错误或问题，需要用户的注意。
	 * @value warning 警告提示场景，用于提示用户关于潜在的问题或需要注意的事项。
	 * @value success 成功提示场景，用于指示一个操作或过程已经成功完成。
	 * @property {Boolean} disabled=[false|true] 组件是否禁用(默认: false) 
	 * @property {Boolean} stop=[false|true] 是否阻止事件冒泡（Tui统一写法处理事件冒泡）(默认: false)
	 * @property {Boolean} hover=[false|true] 是否有点击效果（点击组件透明度0.7）(默认: false)
	 * @property {String} path 点击组件后跳转的页面路径，如果为空则响应点击事件，如果不为空则跳转页面不会响应单击事件。(默认: "")
	 * @property {String} mainClass 组件根节点的样式。(默认: "")
	 * @property {String} nativeClass 组件根节点原生样式。(默认: "")
	 * @property {String} effect=[normal|dark|light|plain] 组件显示主题(默认 "normal")
	 * @value normal 正常
	 * @value dark 深色
	 * @value light 浅色
	 * @value plain 镂空
	 * @property {any} nodes markdown 字符串或kux-markdown解析的node对象
	 */
	
	import { useMarked, TokensList, NodesToken, } from '../../common/marked/index.uts';
	import { CommonProps, useTuiThemes } from '../../common/props/index.uts';
	const marked = useMarked();
	interface MarkedProps extends CommonProps {
		nodes : any
	}
	const props = withDefaults(defineProps<MarkedProps>(), {
		path: '',
		hover: false,
		type: '',
		disabled: false,
		stop: false,
		effect: '',
		size: '',
		mainClass: '',
		nativeClass: '',
		nodes: ''
	});
	const treeList = ref<NodesToken[][][]>([])
	let tokens : NodesToken[] = []
	const noProcessTypes = ref<string[]>(['code', 'table', 'hr'])
	const { extendsAttrs } = useTuiThemes(props)
	const emit = defineEmits(['tolink'])
	if (typeof props.nodes == 'string') {
		const data = marked.lexer(props.nodes as string, null);
		tokens = data.tokens
	} else {
		tokens = props.nodes as NodesToken[]
	}
	function uicon(code : string) {
		// #ifdef APP
		// 将字符串分割成 Unicode 编码的字符
		let codes = code.split('%u');
		// 遍历字符数组
		let chars = codes.map(code => {
			// 转换为十六进制
			let hexCode = parseInt(code, 16);
			// 将 UTF-16 编码转换为字符
			return String.fromCharCode(hexCode);
		});
		// 将字符数组转换成字符串
		return chars.join('');
		// #endif
		// #ifndef APP
		return unescape(`%u${code}`) as string
		// #endif
	}

	function getLeafNodes(items : NodesToken[], parent : NodesToken) : NodesToken[] {
		const list : NodesToken[] = []
		items.forEach((item : NodesToken, index : number) => {
			if (noProcessTypes.value.includes(item.type!)) {
				list.push(item)
				return
			}
			// 设置节点属性
			item.start = parent.start ?? 1
			item.depth = parent.depth ?? 0
			item.deepIndex = (parent.deepIndex ?? 0) + 1
			item.ordered = parent.ordered ?? false
			item.href == null ? (item.href = parent.href ?? '') : ''
			item.checked == null ? (item.checked = parent.checked ?? false) : ''
			if (parent.type == 'list') {
				item.orderedIndex = index
			} else {
				item.orderedIndex = parent.orderedIndex ?? 0
			}

			// 设置 class 默认值为 type
			item.class = item.type
			// 继承父节点的 class
			if (parent.class != null) {
				parent.class.split(' ').forEach((classItem : string) => {
					if (item.class == null) {
						item.class = classItem
					} else if (!item.class.includes(classItem)) {
						item.class = item.class + ' ' + classItem
					}
				})
			}
			// 设置深度
			if (item.depth > 0) {
				item.class = (item.class == null ? '' : item.class + ' ') + 'depth-' + item.depth
			}
			if (item.type == 'list_item') {
				// 插入换行
				const newItem : NodesToken = {
					type: 'text',
					class: 'list-item-br',
					text: "\n"
				}
				list.push(newItem)
				// 插入 list item 缩进的空格
				if (item.deepIndex > 0) {
					// 根据 orderedIndex 的值，插入对应的空格
					const newItem : NodesToken = {
						type: 'text',
						text: "&nbsp;".repeat(item.deepIndex * 2)
					}
					list.push(newItem)
				}
				if (item.task == true) {
					const newItem : NodesToken = {
						type: 'text',
						text: (item.checked == true ? uicon('e607') : uicon('e608')) + ' ',
						class: 'uni-ai-icon list-item-index task' + (item.checked == true ? ' checked' : '')
					}
					list.push(newItem)
				} else if (item.ordered == false) {
					const newItem : NodesToken = {
						type: 'text',
						text: uicon("ec1e"),
						class: 'uni-ai-icon list-item-index unordered'
					}
					list.push(newItem)
				}
				// 插入索引
				if (item.ordered) {
					const newItem : NodesToken = {
						type: 'text',
						text: item.orderedIndex + 1 + '. ',
						class: 'list-item-index'
					}
					list.push(newItem)
				}
			}
			// 拿到子节点
			const nextItems = item.tokens != null && (item.tokens as NodesToken[]).length > 0 ? item.tokens : item.items != null && item.items.length > 0 ? item.items : []
			if (nextItems.length > 0) {
				let nextList = getLeafNodes(nextItems, item)
				list.push(...nextList)
			} else {
				// #ifdef WEB
				// 方便分析，web 端把值为 null 的属性删除
				for (const key in item) {
					if (item[key] == null) {
						delete item[key]
					}
				}
				// #endif

				// 如果上级是链接
				// if (parent.type == 'link') {
				// 	item.inLink = true
				// 	item.class += ' link'
				// 	item.linkHref = parent.href
				// }
				list.push(item)
			}
		});
		return list
	}
	function treeToList(_listToken : NodesToken) : NodesToken[][] {
		const type : string = _listToken.type!
		// 深拷贝，防止修改响应式数据造成无限递归
		const listToken = JSON.parse<NodesToken>(JSON.stringify(_listToken)) as NodesToken
		let lists : NodesToken[] = []
		if (noProcessTypes.value.includes(type)) {
			return [[listToken]]
		} else {
			lists = getLeafNodes(listToken.items ?? listToken.tokens ?? [listToken], listToken)
		}
		// 为了更好的性能，将连续的 text 合并，定义假设条件：所有连续的项类型是一致的，不同类型需要新建一项存放
		const tokenListArr : NodesToken[][] = []
		const listsLength = lists.length
		for (let i = 0; i < listsLength; i++) {
			const item = lists[i]
			const prevItemType : string | null = i > 0 ? lists[i - 1].type : null
			// 当前项和前一项的类型不一致，则将当前元素添加到新的数组中
			if (
				(item.type != prevItemType || (item.type == null && prevItemType == null))
				&& !(prevItemType == 'codespan' && item.type == 'text')
				&& !(prevItemType == 'text' && item.type == 'codespan')
			) {
				tokenListArr.push([])
			}
			const lastItem = tokenListArr[tokenListArr.length - 1]!
			// 每一项的第一项不能是换行
			if (lastItem.length != 0 || item.class != 'list-item-br') {
				lastItem.push(item)
			}
		}
		return tokenListArr
	}
	function toLink(url : string | null) {
		console.log(url)
	}
	const cl : NodesToken[][][] = []
	tokens.forEach((item : NodesToken) => {
		cl.push(treeToList(item))
	})
	treeList.value = cl
</script>
<style lang="scss">
	@font-face {
		// #ifdef WEB
		font-display: swap;
		// #endif
		font-family: uniAiIconFontFamily;
		src: url('/uni_modules/tui-plus/static/font/marked.ttf');
	}

	.uni-ai-icon {
		font-family: uniAiIconFontFamily;
	}

	.text {
		color: #333;
		// line-height: 1.5; // TODO：解决 text 嵌套会重叠文本的问题
		white-space: normal;
		/* #ifndef APP */
		word-break: break-all;
		max-width: 100%;
		/* #endif */
	}

	.strong {
		font-weight: bold;
	}

	.em {
		font-style: italic;
	}

	.del {
		text-decoration-line: line-through;
		color: #999;
	}

	.space {
		height: 10px;
	}

	.link {
		color: #0066cc !important;
		// #ifdef WEB
		cursor: pointer;

		&:hover {
			opacity: 0.8;
		}

		// #endif
	}

	.blockquote-box {
		padding: 5px;
		background: #f5f5f5;
		border-left: 4px solid #ddd;
		width: 100%;
		margin: 5px 0;
	}

	.text {
		font-weight: 400;
	}

	.depth-1 {
		font-size: 30px;
		line-height: 36px;
	}

	.depth-2 {
		font-size: 26px;
		line-height: 34px;
	}

	.depth-3 {
		font-size: 22px;
		line-height: 32px;
	}

	.depth-4 {
		font-size: 20px;
		line-height: 30px;
	}

	.depth-5 {
		font-size: 18px;
		line-height: 28px;
	}

	.depth-6 {
		font-size: 16px;
		color: #999;
		line-height: 24px;
	}

	.hr {
		height: 1px;
		background: #ddd;
		margin: 10px 0;
	}

	.list-content {
		width: 100%;
	}

	.text {
		line-height: 28px;
		white-space: normal;
		width: auto;
	}

	.list-item-content-box {
		flex: 1;

		.list {
			margin-top: 0;
		}
	}

	.list-item-br {
		width: 100%;
	}

	.list-item-index {
		width: 20px;

		&.unordered {
			font-size: 14px;
			color: #000;
		}

		&.task {
			font-size: 14px;
			color: #666;
		}
	}

	.space-box {
		height: 15px;
	}

	.codespan {
		color: #666;
		background-color: #f5f5f5;
		padding: 2px 4px;
		border-radius: 5px;
		font-size: 14px;
	}


	.ui-theme-dark {
		background-color: #25282c;

		.text {
			color: #fff !important;
		}

		.strong {
			color: #fff !important;
		}

		.em {
			color: #fff !important;
		}

		.del {
			color: #999 !important;
		}

		.link {
			color: #0066cc !important;
		}

		.heading {
			color: #fff !important;
		}

		.list {
			.list-item-index {
				color: #fff !important;
			}
		}
	}
</style>